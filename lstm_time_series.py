# -*- coding: utf-8 -*-
"""LSTM_Time_Series.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wDaU_LbP0-N7wHG5qTdyLKqbVXbzO-Z9
"""

import pandas
import matplotlib.pyplot as plt

dataset = pandas.read_csv('/content/airline-passengers.csv' , usecols=[1] , engine='python')
plt.plot (dataset)
plt.show
# trending data " بتعلي لفوق "

import numpy
import matplotlib.pyplot as plt
import pandas
import math
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error

# fix random seed for reproductability
numpy.random.seed(7)

# load the dataset
dataframe = pandas.read_csv('/content/airline-passengers.csv' , usecols=[1] , engine='python')
dataset = dataframe.values
dataset = dataset.astype('float32') # to get the float image of the dataset

# normalize dataset
scaler = MinMaxScaler(feature_range=(0,1))
dataset = scaler.fit_transform(dataset)

# split into train & test
train_size = int(len(dataset) * 0.67) # 67 % train
test_size = int (len(dataset) * 0.33) # 33 % test
train , test = dataset [0:train_size,:] , dataset[train_size:len(dataset) , :]
print(len(train), len(test))

# convert an array of values into a dataset matrix
# lockback is the step wich i lock the state back with
def create_dataset (dataset , lockback=1 ) :
  dataX ,dataY = [] , []
  for i in range (len(dataset)-lockback-1) :
    a = dataset [i:(i+lockback) , 0 ]
    dataX.append(a)
    dataY.append (dataset[i+lockback , 0])
  return numpy.array(dataX) , numpy.array(dataY)

# reshape into x=t , y=t+1
lockback =1
trainX , trainY = create_dataset(train, lockback)
testX , testY = create_dataset (test, lockback)

# reshape input to be [sample , time step , features ]
trainX = numpy.reshape(trainX , (trainX.shape[0] , 1 , trainX.shape[1]))
testX = numpy.reshape(testX , (testX.shape[0] , 1 , testX.shape[1]))

# create and fit the LSTM network
model = Sequential()
model.add(LSTM(4,input_shape=(1,lockback)))
model.add(Dense(1))
model.compile(loss='mean_squared_error' , optimizer='adam')
model.fit(trainX, trainY, epochs=100 ,batch_size=1 , verbose=2)

# make predections
train_predict = model.predict(trainX)
test_predict = model.predict(testX)

# invert predictions
train_predict= scaler.inverse_transform(train_predict)
trainY = scaler.inverse_transform([trainY])

test_predict= scaler.inverse_transform(test_predict)
testY = scaler.inverse_transform([testY])

# calculate root mean squared error
train_score = math.sqrt(mean_squared_error(trainY[0] , train_predict[:,0]))
print('train score : %.2f RMSE ' % (train_score))

test_score = math.sqrt(mean_squared_error(testY[0] , test_predict[:,0]))
print('test score : %.2f RMSE ' % (test_score))

# shift train prediction for plotting
train_predict_plot = numpy.empty_like(dataset)
train_predict_plot [:,:] = numpy.nan
train_predict_plot[lockback:len(train_predict)+lockback , : ] = train_predict

# shift test prediction for plotting
test_predict_plot = numpy.empty_like(dataset)
test_predict_plot [:,:] = numpy.nan
test_predict_plot[lockback:len(test_predict)+lockback , : ] = test_predict

# plot baseline and predictions
plt.plot(scaler.inverse_transform(dataset))
plt.plot(train_predict_plot)
plt.plot(test_predict_plot)
plt.show

# LSTM FOR REGRISION
import numpy
import matplotlib.pyplot as plt
from pandas import read_csv
import math
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error

# convert an array of values into a dataset matrix
# lockback is the step wich i lock the state back with
def create_dataset (dataset , lockback=1 ) :
  dataX ,dataY = [] , []
  for i in range (len(dataset)-lockback-1) :
    a = dataset [i:(i+lockback) , 0 ]
    dataX.append(a)
    dataY.append (dataset[i+lockback , 0])
  return numpy.array(dataX) , numpy.array(dataY)

# fix random seed for reproductability
numpy.random.seed(7)

# load the dataset
dataframe = pandas.read_csv('/content/airline-passengers.csv' , usecols=[1] , engine='python')
dataset = dataframe.values
dataset = dataset.astype('float32') # to get the float image of the dataset

# normalize dataset
scaler = MinMaxScaler(feature_range=(0,1))
dataset = scaler.fit_transform(dataset)

# split into train & test
train_size = int(len(dataset) * 0.67) # 67 % train
test_size = int (len(dataset) * 0.33) # 33 % test
train , test = dataset [0:train_size,:] , dataset[train_size:len(dataset) , :]
print(len(train), len(test))

# reshape into x=t , y=t+1
lockback = 3
trainX , trainY = create_dataset(train, lockback)
testX , testY = create_dataset (test, lockback)

# reshape input to be [sample , time step , features ]
trainX = numpy.reshape(trainX , (trainX.shape[0] , 1 , trainX.shape[1]))
testX = numpy.reshape(testX , (testX.shape[0] , 1 , testX.shape[1]))

# create and fit the LSTM network
model = Sequential()
model.add(LSTM(4,input_shape=(1,lockback)))
model.add(Dense(1))
model.compile(loss='mean_squared_error' , optimizer='adam')
model.fit(trainX, trainY, epochs=100 ,batch_size=1 , verbose=2)

# make predections
train_predict = model.predict(trainX)
test_predict = model.predict(testX)

# invert predictions
train_predict= scaler.inverse_transform(train_predict)
trainY = scaler.inverse_transform([trainY])

test_predict= scaler.inverse_transform(test_predict)
testY = scaler.inverse_transform([testY])

# calculate root mean squared error
train_score = math.sqrt(mean_squared_error(trainY[0] , train_predict[:,0]))
print('train score : %.2f RMSE ' % (train_score))

test_score = math.sqrt(mean_squared_error(testY[0] , test_predict[:,0]))
print('test score : %.2f RMSE ' % (test_score))

# shift train prediction for plotting
train_predict_plot = numpy.empty_like(dataset)
train_predict_plot [:,:] = numpy.nan
train_predict_plot[lockback:len(train_predict)+lockback , : ] = train_predict

# shift test prediction for plotting
test_predict_plot = numpy.empty_like(dataset)
test_predict_plot [:,:] = numpy.nan
test_predict_plot[lockback:len(test_predict)+lockback , : ] = test_predict

# plot baseline and predictions
plt.plot(scaler.inverse_transform(dataset))
plt.plot(train_predict_plot)
plt.plot(test_predict_plot)
plt.show

